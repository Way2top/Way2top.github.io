<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Advanced Python, Way2top&#39;s Personal Blog">
    <meta name="description" content="Advance Python01. decorator（装饰器）1. 基本用法​	decorator，装饰器，为什么会有这个东西呢？先来看一个简单的例子：
1234567def hello1(words : str):    print(&amp;">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Advanced Python | Way2top&#39;s Personal Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 7.3.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Way2top&#39;s Personal Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Way2top&#39;s Personal Blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/22.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Advanced Python</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2025-07-01
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="Advance-Python"><a href="#Advance-Python" class="headerlink" title="Advance Python"></a>Advance Python</h1><h2 id="01-decorator（装饰器）"><a href="#01-decorator（装饰器）" class="headerlink" title="01. decorator（装饰器）"></a>01. decorator（装饰器）</h2><h3 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h3><p>​	decorator，装饰器，为什么会有这个东西呢？先来看一个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hello1</span>(<span class="params">words : <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Welcome!&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello <span class="subst">&#123;words&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Welcome!&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello decorator&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>​	ok，有上面两个函数，可以看到，每个函数都首先要执行一段相同的逻辑，实际在工作中也会经常出现这种情况，可能二三十个函数都要使用相同的一段逻辑，那么我可不可以想一个办法来让代码更加简洁，不那么繁琐呢？</p>
<p>​	装饰器的出现解决了这个问题。那么，要如何设计一个装饰器呢，下面是一段解决上述问题的一个简单的装饰器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">welcome</span>(<span class="params">fn</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Welcome!&quot;</span>)</span><br><span class="line">        result = fn(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<p>​	ok，那么这个函数，实现的效果是：传入一个函数，返回一个函数，这是总体上来看的。</p>
<p>​	那么内部做了什么呢？函数传进来之后，welcome函数内部自己又定义了一个函数，这个就是待会返回的函数。在这个函数中，首先 print 了一下 Welcome，随后就调用了传入的 fn 函数并保存到 result 中并返回。也就是说！！！ wrapper 这个函数做的是，将 welcome 传入的函数原封不动执行一边，另外在它的前面执行了一句 print(“Welcome!”)，这个过程，就可以理解为将传入的函数 decorate 了一下，多了一行 welcome 的输出，然后我再把 wrapper 返回出去。</p>
<p>​	那么然后呢，写完了该怎么实现对原函数的装饰效果呢，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">f1 = welcome(hello1)</span><br><span class="line">f1(<span class="string">&quot;python&quot;</span>)</span><br><span class="line"><span class="comment"># output : </span></span><br><span class="line"><span class="comment"># Welcome!</span></span><br><span class="line"><span class="comment"># Hello python</span></span><br><span class="line"></span><br><span class="line">f2 = welcome(hello2)</span><br><span class="line">f2()</span><br><span class="line"><span class="comment"># output : </span></span><br><span class="line"><span class="comment"># Welcome!</span></span><br><span class="line"><span class="comment"># Hello</span></span><br></pre></td></tr></table></figure>

<p>​	为什么是这样呢，因为 welcome 其实返回的是一个函数，返回的是装饰过后的函数，此时我再给他赋值， welcome 就出现了。</p>
<p>​	但是，但是，你会发现，这好像依旧复杂，似乎比原来还要多写好多行，也没见省事啊。</p>
<p>​	没错，所以诞生了另外一种更加简便的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">welcome</span>(<span class="params">fn</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Welcome!&quot;</span>)</span><br><span class="line">        result = fn(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@welcome</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello1</span>(<span class="params">words : <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello <span class="subst">&#123;words&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@welcome</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello decorator&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hello1(<span class="string">&quot;python&quot;</span>)</span><br><span class="line">hello2()</span><br><span class="line"></span><br><span class="line"><span class="comment"># output :</span></span><br><span class="line"><span class="comment"># Welcome!</span></span><br><span class="line"><span class="comment"># Hello python</span></span><br><span class="line"><span class="comment"># Welcome!</span></span><br><span class="line"><span class="comment"># Hello decorator</span></span><br></pre></td></tr></table></figure>



<p>&#x3D;&#x3D;注意：装饰器必须写在前面，如果上述代码中 welcome() 写在了 hello1 后面就会报错，提示未定义 define。&#x3D;&#x3D;</p>
<h3 id="2-wraps"><a href="#2-wraps" class="headerlink" title="2. @wraps"></a>2. @wraps</h3><p>​	了解了装饰器的基本用法之后，现在又出现了一个新的问题，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">welcome</span>(<span class="params">fn</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Welcome!&quot;</span>)</span><br><span class="line">        result = fn(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@welcome</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello1</span>(<span class="params">words : <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello <span class="subst">&#123;words&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@welcome</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello decorator&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(hello1.__name__) <span class="comment"># wrapper</span></span><br><span class="line"><span class="built_in">print</span>(hello2.__name__) <span class="comment"># wrapper</span></span><br></pre></td></tr></table></figure>

<p>​	可以看到，输出的结果是 wrapper，为什么？很简单，看一下 welcome 的实现逻辑就可以了，很明显，它是直接将 hello1 和 hello2 直接改造换成了 wrapper 函数然后返回，那么当然就会覆盖掉原来的函数信息了。</p>
<p>​	那我不想让原来函数的信息在使用装饰器之后丢失掉该怎么做呢？可以使用 <strong>@wraps</strong>，没错，这是一个系统提供的装饰器，&#x3D;&#x3D;作用就是在自定义装饰器的时候，保留使用该装饰器函数的信息&#x3D;&#x3D;。用法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">welcome</span>(<span class="params">fn</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">fn</span>) </span><span class="comment"># 注意这里要传参，，不能直接用 @wraps</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Welcome!&quot;</span>)</span><br><span class="line">        result = fn(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@welcome</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello1</span>(<span class="params">words : <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello <span class="subst">&#123;words&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@welcome</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello decorator&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(hello1.__name__) <span class="comment"># hello1</span></span><br><span class="line"><span class="built_in">print</span>(hello2.__name__) <span class="comment"># hello2</span></span><br></pre></td></tr></table></figure>

<p>​	此时输出结果就是原本的函数了，这就是 @wraps 的用法。</p>
<h3 id="3-带参数的装饰器"><a href="#3-带参数的装饰器" class="headerlink" title="3. 带参数的装饰器"></a>3. 带参数的装饰器</h3><p>​	还是前面的例子，如果我想灵活一点，希望每次的欢迎语可以自定义，那么，就需要传参，这点如何做到呢？其实只需要在原本的装饰器的外面套一层普通函数就可以了，这个普通函数可以接受一个传参，然后这个传参就可以在整个装饰器内部生效，具体实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">welcome</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">fn</span>):</span><br><span class="line"><span class="meta">        @wraps(<span class="params">fn</span>) </span><span class="comment"># 注意这里要传参，，不能直接用 @wraps</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Welcome, <span class="subst">&#123;name&#125;</span>!&quot;</span>) <span class="comment"># 这里加上传参</span></span><br><span class="line">            result = fn(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@welcome(<span class="params"><span class="string">&quot;release&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello1</span>(<span class="params">words : <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello <span class="subst">&#123;words&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@welcome(<span class="params"><span class="string">&quot;way2top&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello decorator&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hello1(<span class="string">&quot;python&quot;</span>)</span><br><span class="line">hello2()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Welcome, release!</span></span><br><span class="line"><span class="comment"># Hello python</span></span><br><span class="line"><span class="comment"># Welcome, way2top!</span></span><br><span class="line"><span class="comment"># Hello decorator</span></span><br></pre></td></tr></table></figure>

<p>​	在外面套一个简单的函数接收传参就可以了，可以看到输出结果是自定义的。</p>
<p>​	&#x3D;&#x3D;如果把第 13 行 @welcome(“release”) 改一下呢，不传入参数了，也就是：我定义了一个需要传参的装饰器，但是我不传参，那么……&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;结果是不会有任何输出，只有第二个函数 hello2 的输出，这点需要注意。&#x3D;&#x3D;</p>
<h3 id="4-装饰器应用"><a href="#4-装饰器应用" class="headerlink" title="4. 装饰器应用"></a>4. 装饰器应用</h3><p>​	用它来测试不同算法之间的执行时间，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 通用计时器装饰器 ---</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timeit</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;一个装饰器，用于测量并打印函数的执行时间。&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;--- Running <span class="subst">&#123;func.__name__&#125;</span> ---&quot;</span>)</span><br><span class="line">        start = time.perf_counter()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end = time.perf_counter()</span><br><span class="line">        elapsed = (end - start) * <span class="number">1000</span>  <span class="comment"># 转换为毫秒</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用 f-string 进行格式化对齐，方便对比</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;func.__name__:&lt;<span class="number">25</span>&#125;</span> | Time: <span class="subst">&#123;elapsed:&gt;<span class="number">10.3</span>f&#125;</span> ms | Primes found: <span class="subst">&#123;<span class="built_in">len</span>(result):,&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 算法 1: 欧拉筛 (线性筛) ---</span></span><br><span class="line"><span class="comment"># 时间复杂度: O(N) - 理论上最高效的筛法</span></span><br><span class="line"><span class="meta">@timeit</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">euler_sieve</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    欧拉筛 (线性筛) 算法。</span></span><br><span class="line"><span class="string">    核心思想：保证每个合数只被其“最小质因数”筛掉一次。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    is_prime = [<span class="literal">True</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    primes = []  <span class="comment"># 用来存储已找到的质数</span></span><br><span class="line">    is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> is_prime[i]:</span><br><span class="line">            primes.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历已找到的质数列表，用来筛掉合数</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> primes:</span><br><span class="line">            <span class="comment"># 如果 i*p 超出范围，后续的质数也会超出，直接中断</span></span><br><span class="line">            <span class="keyword">if</span> i * p &gt; n:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            is_prime[i * p] = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> i % p == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> primes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 算法 2: 埃氏筛 (Sieve of Eratosthenes) ---</span></span><br><span class="line"><span class="comment"># 时间复杂度: O(N log log N) - 非常高效，但略逊于欧拉筛</span></span><br><span class="line"><span class="meta">@timeit</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eratosthenes_sieve</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    标准的埃氏筛算法。</span></span><br><span class="line"><span class="string">    核心思想：从2开始，每找到一个质数，就把它所有的倍数都标记为合数。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    is_prime = [<span class="literal">True</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 优化1: 外层循环只需要遍历到 sqrt(n)</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(n ** <span class="number">0.5</span>) + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 如果 p 仍然是质数</span></span><br><span class="line">        <span class="keyword">if</span> is_prime[p]:</span><br><span class="line">            is_prime[p * p: n + <span class="number">1</span>: p] = [<span class="literal">False</span>] * <span class="built_in">len</span>(<span class="built_in">range</span>(p * p, n + <span class="number">1</span>, p))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 收集所有质数</span></span><br><span class="line">    primes = [i <span class="keyword">for</span> i, is_p <span class="keyword">in</span> <span class="built_in">enumerate</span>(is_prime) <span class="keyword">if</span> is_p]</span><br><span class="line">    <span class="keyword">return</span> primes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 性能对比测试 ---</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    n = <span class="number">1000000</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;======&gt; Starting prime sieve comparison for n = <span class="subst">&#123;n:,&#125;</span> &lt;======\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行埃氏筛</span></span><br><span class="line">    eratosthenes_sieve(n)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;=&quot;</span> * <span class="number">60</span> + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行欧拉筛</span></span><br><span class="line">    euler_sieve(n)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\n======&gt; Comparison finished. &lt;======&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">======&gt; Starting prime sieve comparison <span class="keyword">for</span> n = <span class="number">1</span>,<span class="number">000</span>,<span class="number">000</span> &lt;======</span><br><span class="line"></span><br><span class="line">--- Running eratosthenes_sieve ---</span><br><span class="line">eratosthenes_sieve        | Time:     <span class="number">46.478</span> ms | Primes found: <span class="number">78</span>,<span class="number">498</span></span><br><span class="line"></span><br><span class="line">============================================================</span><br><span class="line"></span><br><span class="line">--- Running euler_sieve ---</span><br><span class="line">euler_sieve               | Time:    <span class="number">125.815</span> ms | Primes found: <span class="number">78</span>,<span class="number">498</span></span><br><span class="line"></span><br><span class="line">======&gt; Comparison finished. &lt;======</span><br></pre></td></tr></table></figure>

<p>​	这就是装饰器的实际应用之一，其实在工作中很多时候还会用它来打印日志文件。</p>
<p>​	这里额外提一嘴，实际上欧式筛时间复杂度是优于埃氏筛的，前者是 O(n)，后者是  O(nloglogn)，那为什么实际输出结果是埃氏筛时间短于欧式筛呢？</p>
<p>​	其实是因为使用的是Python，所以，<strong>欧拉筛的“理论优势”在 Python 中往往被语言执行效率抵消</strong>，而<strong>埃氏筛结构简单、列表切片高效</strong>，导致它在 Python 里跑得更快，哪怕 $n &#x3D; 10^8$ 也是如此。</p>
<p>​	但是同样的逻辑写在 C++ 中就很明显了，欧式筛就是优于埃氏筛的。</p>
<h2 id="02-generator（生成器）"><a href="#02-generator（生成器）" class="headerlink" title="02. generator（生成器）"></a>02. generator（生成器）</h2><h3 id="1-iterable-iterator"><a href="#1-iterable-iterator" class="headerlink" title="1. iterable&amp;iterator"></a>1. iterable&amp;iterator</h3><p>​	iterable是可迭代对象，iterator是迭代器，在了解generator之前有必要了解一下这两个概念。</p>
<p>​	可迭代对象（iterable）是能够返回迭代器的对象，换句话说，只要一个对象实现了 <code>__iter__()</code> 方法 或者一个 <code>__gettiem__()</code> 方法（注意：<code>__getitem__()</code> 能被当作 iterable 是 Python 的一个兼容特性，现代推荐用 <code>__iter__()</code> 明确表示可迭代），那它就是可迭代对象。常见的 iterable 包括&#x3D;&#x3D;列表、元组、字典、集合、字符串&#x3D;&#x3D;等，都是可迭代对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]  <span class="comment"># 这是一个可迭代对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式一：借助 iter() 函数获取迭代器</span></span><br><span class="line">iter_obj = <span class="built_in">iter</span>(my_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二：在 for 循环内部自动调用 iter()</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> my_list:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure>



<p>​	迭代器（iterator）是实现了<code>__iter__()</code> 和 <code>__next__()</code> 方法的对象，其中<code>__iter__()</code>方法会返回迭代器自身，而 <code>__next__()</code>方法则会返回序列中的下一个元素。当序列中没有元素可供返回的时候，<code>__next__()</code>方法会抛出 <code>StopIteration</code> 异常。迭代器的主要作用就是记录迭代状态。下面我自定义了一个迭代器，可以结合上面说的来了解：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EvenNumber</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, max_num</span>):</span><br><span class="line">        <span class="variable language_">self</span>.max_num = max_num</span><br><span class="line">        <span class="variable language_">self</span>.current = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.current &gt;= <span class="variable language_">self</span>.max_num:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        </span><br><span class="line">        result = <span class="variable language_">self</span>.current</span><br><span class="line">        <span class="variable language_">self</span>.current += <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">evens = EvenNumber(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> evens:</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>可迭代对象</strong></th>
<th><strong>迭代器</strong></th>
</tr>
</thead>
<tbody><tr>
<td>核心方法</td>
<td><code>__iter__()</code> 或 <code>__getitem__()</code></td>
<td><code>__iter__()</code> 和 <code>__next__()</code></td>
</tr>
<tr>
<td>能否使用 <code>iter()</code></td>
<td>可以</td>
<td>可以（返回迭代器自身）</td>
</tr>
<tr>
<td>能否使用 <code>next()</code></td>
<td>不可以</td>
<td>可以</td>
</tr>
<tr>
<td>状态记录</td>
<td>不记录</td>
<td>记录当前迭代位置</td>
</tr>
<tr>
<td>能否多次迭代</td>
<td>通常可以</td>
<td>不可以（只能迭代一次）</td>
</tr>
</tbody></table>
<p>​	有关 iterable 和 iterator，为什么 iterable 能够多次循环调用，而 iterator 只能一次？实际上是因为<strong>每次调用 <code>iter()</code> 会返回新的 iterator，因此可以多次迭代</strong>；iterator：<strong>迭代一次之后就 exhausted（耗尽）</strong></p>
<h3 id="2-generator"><a href="#2-generator" class="headerlink" title="2. generator"></a>2. generator</h3><p>​	可以看到，如果我想写一个自定义的迭代器，是非常麻烦的，又要定义类，又要自定义 <code>__iter__()</code> 和 <code>__next__()</code>，那么，有没有一种方法可以更简便的来实现迭代器呢？这就是 <code>generator</code> 所解决的问题了。</p>
<p>​	要了解 <code>generator</code>，首先需要了解 <code>yield</code> 的用法，来看下面一段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">s1</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;s1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">s2</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;s2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">s3</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;s3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;step 01&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> s1()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;step 02&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> s2()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;step 03&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> s3()</span><br><span class="line"></span><br><span class="line">g = hello()</span><br><span class="line"><span class="built_in">print</span>(g)</span><br><span class="line"><span class="comment"># &lt;generator object hello at 0x0000028F0D294D00&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line"><span class="comment"># step 01</span></span><br><span class="line"><span class="comment"># s1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line"><span class="comment"># step 02</span></span><br><span class="line"><span class="comment"># s2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line"><span class="comment"># step 03</span></span><br><span class="line"><span class="comment"># s3</span></span><br></pre></td></tr></table></figure>

<p>​	程序在被调用之后，会返回一个 <code>generator</code>，也就是 g，代码中的 变量 g 在接收 hello() 之后就变成了一个生成器对象，在这一行代码执行之后，实际上如果你直接 print(g) 的话，会得到的结果是 g 这个 generator 对象，而不会得到任何返回值，<strong>另外，执行 g &#x3D; hello() 的时候，实际上 hello() 函数一句都不会执行。</strong></p>
<p>​	<code>yield</code>和<code>return</code>的区别也在于此，当函数执行到 return 的时候会直接结束，但是执行到 yield 的时候则不会，直到函数返回的 generator 被  <code>next()</code>方法调用的时候，才会继续往下走。</p>
<p>​	那么其实讲到这里，就可以发现，<strong>&#x3D;&#x3D;genarator 可以简化 iterator 的写法&#x3D;&#x3D;</strong>，这就是 generator 的第一个作用。</p>
<p>​	generator 的第二个作用，&#x3D;&#x3D;<strong>是它可以极大地优化内存，具有很高的性能</strong>&#x3D;&#x3D;。为什么这么说？因为 generator 是一个典型的 <code>Lazy Object</code>，它只有在被调用的时候才会执行。上面也讲到了，上面例子中函数执行到 g &#x3D; hello() 的时候，实际上 hello() 这个函数一句都没有执行，而普通函数的话在使用 g &#x3D; hello() 的时候，实际上函数已经跑一遍了。generator 的这个特性使得它能够优化内存，优化性能。</p>
<p>​	关于性能优化方面，这里举一个具体的例子可以加深体会，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_large_file</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            <span class="keyword">yield</span> line</span><br><span class="line"></span><br><span class="line"><span class="comment"># 逐行处理，不占用大量内存</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> read_large_file(<span class="string">&#x27;big.txt&#x27;</span>):</span><br><span class="line">    process(line)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	显然，如果不使用 generator，会一次性把所有内容全部读到内存，而如果使用 generator，每次只会读一行。</p>
<h3 id="3-补充：yield-和-return-的区别"><a href="#3-补充：yield-和-return-的区别" class="headerlink" title="3. 补充：yield 和 return 的区别"></a>3. 补充：yield 和 return 的区别</h3><p>​	前面讲这两者的区别其实讲的不是完全正确，这里展开讲一下。</p>
<p>​	<strong><code>return</code>：用于普通函数，立即结束函数执行并返回一个值。</strong></p>
<p>​	<strong><code>yield</code>：用于生成器函数，暂停函数执行，返回一个值，并保留函数当前状态，下次继续执行。</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>return</code></th>
<th><code>yield</code></th>
</tr>
</thead>
<tbody><tr>
<td>用于的函数类型</td>
<td>普通函数</td>
<td>生成器函数（generator）</td>
</tr>
<tr>
<td>函数调用后返回</td>
<td>立即执行，返回一个值</td>
<td>返回一个生成器对象（不执行函数体）</td>
</tr>
<tr>
<td>是否结束函数</td>
<td>✅ 结束函数执行</td>
<td>❌ 不结束，挂起函数执行</td>
</tr>
<tr>
<td>返回什么</td>
<td>一个值（任意类型）</td>
<td>每次迭代一个值</td>
</tr>
<tr>
<td>多次使用时</td>
<td>只能返回一次</td>
<td>可以多次挂起和恢复，每次返回一个新值</td>
</tr>
<tr>
<td>执行方式</td>
<td>函数一旦调用就完整执行</td>
<td>需用 <code>next()</code> 推进一步步执行</td>
</tr>
<tr>
<td>内部状态保留</td>
<td>❌ 不保留，return 后局部变量都销毁</td>
<td>✅ 保留局部变量、执行位置</td>
</tr>
<tr>
<td>适合场景</td>
<td>一次性返回一个结果</td>
<td>惰性计算、流式处理、大数据、迭代器</td>
</tr>
</tbody></table>
<h2 id="03-类与装饰器-》"><a href="#03-类与装饰器-》" class="headerlink" title="03. 类与装饰器&#x3D;&#x3D;&#x3D;&#x3D;》"></a>03. 类与装饰器&#x3D;&#x3D;&#x3D;&#x3D;》</h2><h3 id="1-用类定义函数装饰器"><a href="#1-用类定义函数装饰器" class="headerlink" title="1. 用类定义函数装饰器"></a>1. 用类定义函数装饰器</h3><h4 id="1-魔法方法-call"><a href="#1-魔法方法-call" class="headerlink" title="(1) 魔法方法 __call__()"></a>(1) 魔法方法 <code>__call__()</code></h4><p>​	首先了解一下<code>__call__()</code>这个魔法方法的作用，一句话来说就是：&#x3D;&#x3D;当一个类的对象被当做函数调用的时候，就会触发 <code>__call__()</code>函数&#x3D;&#x3D;，具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MagicMethodCall</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, magic</span>):</span><br><span class="line">        <span class="variable language_">self</span>.magic = magic</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwds</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Magic Method __call__() is executed.&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;magic = <span class="subst">&#123;self.magic&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = MagicMethodCall(<span class="number">50</span>)</span><br><span class="line">c()</span><br><span class="line"><span class="comment"># Magic Method __call__() is executed.</span></span><br><span class="line"><span class="comment"># magic = 50</span></span><br></pre></td></tr></table></figure>

<p>​	可以看到，当对象 c 被当做函数执行的时候，自动调用了 <code>__call__()</code> 函数中的内容。</p>
<h4 id="2-用类来实现装饰器（无传参）"><a href="#2-用类来实现装饰器（无传参）" class="headerlink" title="(2) 用类来实现装饰器（无传参）"></a>(2) 用类来实现装饰器（无传参）</h4><p>​	前面在装饰器部分，我使用了函数来实现装饰器，在这部分，我会使用类来实现装饰器。要想做到使用类来实现装饰器，就需要用到上面的 <code>__call__()</code> 魔法方法，具体实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用类实现无传参的装饰器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDecorator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, f</span>):</span><br><span class="line">        <span class="variable language_">self</span>.f = f</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwds</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;welcome&quot;</span>)</span><br><span class="line">        result = <span class="variable language_">self</span>.f(*args, **kwds)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;bye&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原始调用</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"></span><br><span class="line">f = MyDecorator(hello)</span><br><span class="line">f()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 语法糖</span></span><br><span class="line"><span class="meta">@MyDecorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"></span><br><span class="line">hello()</span><br></pre></td></tr></table></figure>

<p>​	当 Python 解释器执行到 <code>@MyDecorator</code> 时，实际上会将被装饰的函数作为参数传入 <code>MyDecorator(func)</code>，从而创建一个类的实例对象。这个实例必须实现了 <code>__call__()</code> 方法，因此它是“可调用的对象”。此时并不会立刻调用 <code>__call__()</code>，而是将这个可调用对象作为新的函数替换原函数。以后每次调用这个函数时，其实是调用这个对象的 <code>__call__()</code> 方法，装饰器的逻辑也就写在 <code>__call__()</code> 方法中。</p>
<h4 id="3-用类来实现装饰器（有传参）"><a href="#3-用类来实现装饰器（有传参）" class="headerlink" title="(3) 用类来实现装饰器（有传参）"></a>(3) 用类来实现装饰器（有传参）</h4><p>​	前面实现了无传参的类装饰器，那么，有传参的类装饰器该如何实现呢？还是先看代码，看完再解释：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ParamDecorator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, f</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Welcome <span class="subst">&#123;self.name&#125;</span>&quot;</span>)</span><br><span class="line">            result = f(*args, **kwargs)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Bye <span class="subst">&#123;self.name&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ParamDecorator(<span class="params"><span class="string">&quot;release&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"></span><br><span class="line">hello()</span><br></pre></td></tr></table></figure>

<p>​	可以看到，其实和前面没有传参的写法已经不太一样了，没事，我们把这段代码掰开揉碎了讲。</p>
<p>​	首先我们应该先看下面的代码，不要看类的具体实现，现将目光锁定到第14行，<code>@ParamDecorator(&quot;release&quot;)</code>，这是在干嘛呢？</p>
<p>​	如果不看这个@，那么其实它就是在创建一个对象，传入了一个 “release” 的参数，那既然传入了一个参数，那我类中肯定要接收一下这个参数，所以 <code>__init__()</code>这里肯定要有一个传参，那么，类的初始化部分就看完了。</p>
<p>​	接下来是 <code>__call__()</code> 部分，这里和前面无传参的时候就有比较大的变化了，可以看到传入的是一个函数，为什么？为什么在这里要用一个函数作为传参呢？这是因为，在执行完 <code>@ParamDecorator(&quot;release&quot;)</code> 之后，如果后面跟了函数，那么会将后面跟着的函数作为参数传给这个类（这一点可以参考前面，讲解 decorator 的时候，两种等价的写法，这可以帮助理解），因此，<code>__call__()</code> 是需要接收一个函数的，这个接收的函数就是需要被装饰的函数。</p>
<p>​	<code>__call__()</code>接下来的部分就好理解了，这里其实就和函数实现装饰器的部分一模一样了。</p>
<p>​	那么通过这样一个类，就可以实现有传参的类装饰器了。</p>
<h4 id="4-有传参-vs-无传参"><a href="#4-有传参-vs-无传参" class="headerlink" title="(4)有传参 vs. 无传参"></a>(4)有传参 vs. 无传参</h4><p>​	前面讲了这么多可能会比较乱，这里简单做一下对比和总结。</p>
<p>​	对于无传参，<code>__call__()</code> 的职责是：<strong>直接接收函数的调用请求，执行装饰逻辑，相当于“充当函数”来用</strong></p>
<p>​	对于有传参，<code>__call__()</code> 的职责是：<strong>接收原始函数，返回一个内部定义的装饰器函数（通常是 wrapper）</strong></p>
<h4 id="5-补充：如何保留被装饰函数的信息"><a href="#5-补充：如何保留被装饰函数的信息" class="headerlink" title="(5) 补充：如何保留被装饰函数的信息"></a>(5) 补充：如何保留被装饰函数的信息</h4><p>​	在前面函数实现装饰器的部分，我提到了一个 <code>@wraps</code> ，这个系统提供的装饰器，可以帮助我们保留函数信息，那么在类中如何保留被装饰函数的信息呢？这里也需要用到一个库函数的方法：<code>functools.update_wrapper(self, func)</code></p>
<p>​	实现也很简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 无传参</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> update_wrapper</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDecorator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, f</span>):</span><br><span class="line">        <span class="variable language_">self</span>.f = f</span><br><span class="line">        update_wrapper(<span class="variable language_">self</span>, f) <span class="comment"># 这里添加即可实现保留原函数信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwds</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;welcome&quot;</span>)</span><br><span class="line">        result = <span class="variable language_">self</span>.f(*args, **kwds)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;bye&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有传参</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParamDecorator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, f</span>):</span><br><span class="line"><span class="meta">        @wraps(<span class="params">f</span>) </span><span class="comment"># 这里写法其实和函数实现 decorator 一致，注意 @wraps要有参数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Welcome <span class="subst">&#123;self.name&#125;</span>&quot;</span>)</span><br><span class="line">            result = f(*args, **kwargs)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Bye <span class="subst">&#123;self.name&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>





<h3 id="2-给类定义装饰器-》"><a href="#2-给类定义装饰器-》" class="headerlink" title="2. 给类定义装饰器&#x3D;&#x3D;&#x3D;&#x3D;》"></a>2. 给类定义装饰器&#x3D;&#x3D;&#x3D;&#x3D;》</h3><h4 id="1-为什么要给类定义装饰器"><a href="#1-为什么要给类定义装饰器" class="headerlink" title="(1)为什么要给类定义装饰器"></a>(1)为什么要给类定义装饰器</h4><h4 id="2-如何实现"><a href="#2-如何实现" class="headerlink" title="(2) 如何实现"></a>(2) 如何实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cls_decorator</span>(<span class="params">cls</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start to decorate&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">        obj = cls()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Bye&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@cls_decorator</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br></pre></td></tr></table></figure>



















<h2 id="04-type"><a href="#04-type" class="headerlink" title="04. type"></a>04. type</h2><h3 id="1-type-新理解"><a href="#1-type-新理解" class="headerlink" title="1. type 新理解"></a>1. <code>type</code> 新理解</h3><p>​	提到 <code>type</code>，诶，好熟悉啊，从刚学习 Python 基础语法的时候就在用 <code>type</code> 了，我们用它来查看变量的类型。这似乎和前面的 decorator、generator 这些生僻的不常见的用法完全不是同一级别的感觉啊。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 刚学习Python时，type的用法</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">3.14</span></span><br><span class="line">c = <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">d = <span class="literal">True</span></span><br><span class="line">e = [<span class="number">1</span>, <span class="number">2</span> ,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a)) <span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b)) <span class="comment"># &lt;class &#x27;float&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(c)) <span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(d)) <span class="comment"># &lt;class &#x27;bool&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(e)) <span class="comment"># &lt;class &#x27;list&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>​	所以，<code>type</code> 凭什么出现在 Python 高级语法篇呢？我们看看下面这段代码：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greeting</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(person)) <span class="comment"># &lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(person, <span class="built_in">type</span>)) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>



<p>​	这时候你会发现，怎么我创建了一个 person 类，打印出来的 <code>type</code> 是 <code>type</code> 呢？这时候，脑海里出现一句话：“在Python中，万物皆对象。”</p>
<p>​	那么说明，<code>type</code> 也是一个对象？那 person 的打印结果是 <code>type</code> 类，说明：自定义的 <code>person</code> 类，其实是 <code>type</code> 类的一个对象了。这好像和我想的不太一样？</p>
<p>​	事实的确如此。<code>type</code> 本身是一个类，而所有自定义的类，本身其实也是一个对象，是 <code>type</code> 类的对象。到此，我们对 <code>type</code> 有了一个全新的认识。</p>
<p>​	总结一下：</p>
<ul>
<li><code>type</code> 是一个类，它是所有类的“制造者”。</li>
<li><code>object</code> 是所有类的父类（即基类）。</li>
<li><strong>关键是：<code>type</code> 本身也是一个对象，它是 <code>type</code> 的实例自己造自己</strong></li>
</ul>
<h3 id="2-type-的高级用法"><a href="#2-type-的高级用法" class="headerlink" title="2. type 的高级用法"></a>2. <code>type</code> 的高级用法</h3><p>​	那么对 <code>type</code> 有了新的认识之后，它有什么高级用法呢？它可以用来<strong>动态</strong>自定义一个类。具体用法如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># type 的高级用法</span></span><br><span class="line">class_body = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">def greeting(self):</span></span><br><span class="line"><span class="string">    print(&#x27;Hello World&#x27;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">class_dict = &#123;&#125;</span><br><span class="line"><span class="built_in">exec</span>(class_body, <span class="built_in">globals</span>(), class_dict)</span><br><span class="line"></span><br><span class="line">Hello = <span class="built_in">type</span>(<span class="string">&quot;Hello&quot;</span>, (<span class="built_in">object</span>,), class_dict)</span><br><span class="line"></span><br><span class="line">h = Hello()</span><br><span class="line">h.greeting() <span class="comment"># output: Hello World</span></span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>​	我们来拆解一下上面这段程序：首先看第 10 行，<code>Hello = type(&quot;Hello&quot;, (object,), class_dict)</code> ，这一句就是 <code>type</code> 的语法，第一个传参是一个<strong>字符串</strong>，会作为动态定义的类的名字；第二个传参的意思是继承自 <code>object</code>，也就是将基类作为父类（代码中的写法我提一嘴，这里传入的是一个元组，而单个元素的元组需要加一个逗号）；第三个传参则是定义的类的内容，这个传参<strong>要求是一个字典</strong>；</p>
<p>​	第一个参数好理解，类名嘛；第二个也好理解，type 本身就是继承自父类，自然动态创建对象（这里的对象指的是自定义的类，前面讲过了，其实自定义的类本身就是 <code>type</code> 的一个对象）需要继承一下；但是第三部分，说需要传入一个字典，这个字典定义的是类的内容，这句话怎么理解？</p>
<p>​	我们说这里要传入一个字典，怎么来？其实你看代码也可以大概知道，这个字典是通过一个字符串，然后将这个字符串 <code>exec()</code> 了一下，就变成了一个字典。我们这里不讨论 <code>exec()</code> 的语法，我们只需要知道它可以将一个字符串转化为字典就可以了。这里其实 <code>class_body</code> 就是我们实现动态定义一个类的关键。</p>
<p>​	为什么一个字符串就能自定义了？因为我们可以将这个字符串写在程序之外，可以是一个文本文件，我随时修改这个文件的内容，每次创建的类的属性和方法就不一样，这样就实现了动态创建一个类。这就是 type 的高级用法。</p>
<p>​	这个高级用法在实际中其实用的还是比较少的，所以做一个了解就可以了。之后如果需要动态定义一个类，脑子中能有一个印象，可以想到 <code>type</code> 再来看语法就行了。</p>
<h3 id="3-补充：exec"><a href="#3-补充：exec" class="headerlink" title="3. 补充：exec()"></a>3. 补充：<code>exec()</code></h3><p>​	上面我没有详细展开聊 exec() 的用法，其实我的表述是有部分不太准确的，<code>exec(class_body, globals(), class_dict)</code> 是<strong>在给定字典作用域下执行代码</strong>。</p>
<p>​	如果这个代码里定义了函数或变量，它们会<strong>作为 key-value 对象被填进 <code>class_dict</code> 这个字典里</strong>。</p>
<p>​	也就是说，<code>exec()</code> 并不是“把字符串转字典”，而是“执行后把局部作用域的变量放进这个字典”。</p>
<p>​	ps：其实我还是没懂，ai写的，反正不要直接理解成把字符串转化为字典就好了。</p>
<h2 id="05-closure"><a href="#05-closure" class="headerlink" title="05. closure"></a>05. closure</h2><p><code>closure</code>，闭包，这个名词可能你之前没怎么听说过，我们可以先从下面这段程序开始理解它：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">python复制编辑<span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">g</span>():</span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> g</span><br><span class="line"></span><br><span class="line">g1 = f()</span><br><span class="line">g1()  <span class="comment"># 输出: 2</span></span><br><span class="line"><span class="built_in">print</span>(g1.__closure__)  <span class="comment"># (&lt;cell at 0x000002F7075FACE0: int object at 0x00007FFA90FCE448&gt;,)</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-闭包的基本现象"><a href="#1-闭包的基本现象" class="headerlink" title="1. 闭包的基本现象"></a>1. 闭包的基本现象</h3><p>这段代码中，一个函数 <code>f()</code> 里面又定义了一个函数 <code>g()</code>，并且 <code>g()</code> 使用了 <code>f()</code> 中的局部变量 <code>a</code>。这种现象称为“闭包现象”，而 <code>g()</code> 就是“闭包函数”或“闭包”。</p>
<p>补充说明：</p>
<ul>
<li>如果 <code>g()</code> 虽然是内部函数，但没有使用外部函数 <code>f()</code> 的局部变量，那就<strong>不是闭包</strong>。</li>
</ul>
<hr>
<h3 id="2-g1-为什么能输出值？"><a href="#2-g1-为什么能输出值？" class="headerlink" title="2. g1() 为什么能输出值？"></a>2. g1() 为什么能输出值？</h3><p>注意我们执行了 <code>g1 = f()</code>，此时 <code>f()</code> 已经执行完成，它的局部变量 <code>a</code> 按照 Python 的变量作用域规则来说，应该被销毁了。那么为什么后面 <code>g1()</code> 还能正常输出 <code>a</code> 的值（输出结果是 2），而不是报错？</p>
<p>是不是 Python 特意延长了变量 <code>a</code> 的生命周期？乍一听挺合理，但真实原因比这个更深入。</p>
<hr>
<h3 id="3-来看看-closure-是什么"><a href="#3-来看看-closure-是什么" class="headerlink" title="3. 来看看 closure 是什么"></a>3. 来看看 <strong>closure</strong> 是什么</h3><p>我们来看下面这段代码：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a = 10 时地址：&quot;</span>, <span class="built_in">hex</span>(<span class="built_in">id</span>(a)))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">g</span>():</span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a = 2 时地址：&quot;</span>, <span class="built_in">hex</span>(<span class="built_in">id</span>(a)))</span><br><span class="line">    <span class="keyword">return</span> g</span><br><span class="line"></span><br><span class="line">g1 = f()</span><br><span class="line">g1()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;g1.__closure__ =&quot;</span>, g1.__closure__)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;闭包中变量的实际值 =&quot;</span>, g1.__closure__[<span class="number">0</span>].cell_contents)</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span> 时地址： <span class="number">0x7ffa90fce448</span></span><br><span class="line">a = <span class="number">2</span> 时地址： <span class="number">0x7ffa90fce348</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">g1.__closure__ = (&lt;cell at <span class="number">0x000001D4B76FBA00</span>: <span class="built_in">int</span> <span class="built_in">object</span> at <span class="number">0x00007FFA90FCE348</span>&gt;,)</span><br><span class="line">闭包中变量的实际值 = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>可以看到：</p>
<ul>
<li><code>a = 10</code> 和 <code>a = 2</code> 的内存地址确实不一样，这是因为整型是不可变类型，修改值就会生成新对象。</li>
<li><code>__closure__</code> 中包含了一个 <code>cell</code> 对象，这个 <code>cell</code> 对象中保存着 <code>int</code> 类型的值 <strong>2</strong>，而且地址刚好等于 <code>a = 2</code> 的地址。</li>
</ul>
<p>那么问题来了：<code>a</code> 是 <code>f()</code> 的局部变量，<code>f()</code> 执行完不是早就被释放了吗？为什么 <code>g1()</code> 还能用到这个值呢？</p>
<hr>
<h3 id="4-闭包变量不是复制的，是引用"><a href="#4-闭包变量不是复制的，是引用" class="headerlink" title="4. 闭包变量不是复制的，是引用"></a>4. 闭包变量不是复制的，是引用</h3><p>​	难道说，闭包函数复制了一份局部变量并保存在自己的 <code>__closure__</code> 中吗？事实并非如此。</p>
<blockquote>
<p>闭包函数不是复制变量，而是<strong>持有对那个变量的 cell 对象的引用</strong>。这个 cell 对象会捕获 <code>a</code> 的绑定对象，保存在 <code>g.__closure__</code> 中。只要 <code>g</code> 还活着，变量 <code>a</code> 就不会被释放。</p>
</blockquote>
<p>所以，<code>f()</code> 中的变量 <code>a</code> 被编译器优化成了一个 <strong>cell variable</strong>，然后 <code>g</code> 返回时，它的 <code>__closure__</code> 属性就把这个 cell 给保存下来了。你可以理解为：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g1.__closure__[<span class="number">0</span>].cell_contents --&gt; 就是 a 的值 <span class="number">2</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-为什么地址还能对得上？"><a href="#5-为什么地址还能对得上？" class="headerlink" title="5. 为什么地址还能对得上？"></a>5. 为什么地址还能对得上？</h3><p>实际上：</p>
<ul>
<li><code>g1.__closure__</code> 持有 <code>a</code> 的 <strong>引用</strong>，<code>a = 2</code> 时这个对象已经绑定在 cell 上了；</li>
<li>函数返回后，虽然变量名 <code>a</code> 被清理了，但 <code>2</code> 这个对象还被闭包持有，所以没释放；</li>
<li>所以地址一样，是因为这是 <strong>同一个对象</strong>，并没有删了又建。</li>
</ul>
<hr>
<h3 id="6-闭包的应用及注意事项"><a href="#6-闭包的应用及注意事项" class="headerlink" title="6. 闭包的应用及注意事项"></a>6. 闭包的应用及注意事项</h3><h5 id="✅-闭包的常见用途："><a href="#✅-闭包的常见用途：" class="headerlink" title="✅ 闭包的常见用途："></a>✅ 闭包的常见用途：</h5><ol>
<li><strong>记住状态</strong>：比如计数器、缓存（如单例模式）等</li>
<li><strong>实现装饰器</strong>：装饰器本质就是闭包</li>
<li><strong>函数式编程</strong>：函数返回另一个函数</li>
</ol>
<h5 id="✅-注意事项：变量绑定"><a href="#✅-注意事项：变量绑定" class="headerlink" title="✅ 注意事项：变量绑定"></a>✅ 注意事项：变量绑定</h5><p>闭包函数内部若要修改外部变量，需要使用 <code>nonlocal</code>：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_counter</span>():</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inc</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> count</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    <span class="keyword">return</span> inc</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><ul>
<li>闭包是指：<strong>内部函数引用了外部函数的局部变量，并且外部函数返回了这个内部函数</strong>。</li>
<li>被引用的变量会被<strong>封装成 cell</strong>，保存在返回的函数的 <code>__closure__</code> 中。</li>
<li>这些变量<strong>不是复制的，是引用的</strong>；只要闭包还活着，这些变量就不会被释放。</li>
<li>查看闭包变量可以用 <code>func.__closure__[i].cell_contents</code>。</li>
</ul>
<h2 id="06-Python的变量名"><a href="#06-Python的变量名" class="headerlink" title="06. Python的变量名"></a>06. Python的变量名</h2><p>​	简单聊一下 Python 的变量名。</p>
<p>​	先说结论：<strong>在 Python 中，变量名不是装值的盒子，而是指向对象的“标签”</strong>。</p>
<p>​	我们先看这样一段简单的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>​	很简单对吧，我将 10 这个值赋给了变量 <code>a</code>。</p>
<p>​	这个过程其实我们应该看得更深一点，在 Python 中，所有的数据都是对象：比如整数、字符串、列表、函数等。而所有的变量名其实都是一个名字（标识符），这个名字被绑定（bind）到了某个对象上。所以其实上面这行代码就是 变量名 <code>a</code> 被绑定到了 10 这个对象上。</p>
<p>​	<strong>所以变量 &#x3D; “名字 + 引用”，而不是“一个可以装值的空间”。</strong></p>
<hr>
<h3 id="1-多个变量名绑定同一个对象"><a href="#1-多个变量名绑定同一个对象" class="headerlink" title="1. 多个变量名绑定同一个对象"></a>1. 多个变量名绑定同一个对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">b.append(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>​	这说明变量 <code>a</code> 和 <code>b</code> 虽然是两个名字，但它们指向的是同一个列表对象。因此修改 <code>b</code>，<code>a</code> 的内容也会变化。</p>
<hr>
<h3 id="2-变量重新绑定对象"><a href="#2-变量重新绑定对象" class="headerlink" title="2. 变量重新绑定对象"></a>2. 变量重新绑定对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">a = <span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<p>​	这不是把 <code>10</code> 替换成了 <code>&quot;hello&quot;</code>，而是将变量名 <code>a</code> 重新绑定到了字符串对象 <code>&quot;hello&quot;</code> 上。原来的 <code>10</code> 对象如果没人引用，就会被 Python 的垃圾回收机制清除。这里其实还可以想到一个原因，整数类型是不可变的，所以 <code>a</code> 会指向一个新的地址，而上面的 list 是可以改变的。</p>
<hr>
<h3 id="3-使用-id-查看对象地址"><a href="#3-使用-id-查看对象地址" class="headerlink" title="3. 使用 id() 查看对象地址"></a>3. 使用 <code>id()</code> 查看对象地址</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line">y = x</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(x))  <span class="comment"># 比如 4456789120</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(y))  <span class="comment"># 与 x 相同，说明它们指向同一个对象</span></span><br></pre></td></tr></table></figure>

<p>​	<code>id()</code> 可以理解为“对象的内存地址”。如果两个变量的 <code>id</code> 相同，它们指向同一个对象。</p>
<hr>
<h3 id="4-变量名与作用域绑定表"><a href="#4-变量名与作用域绑定表" class="headerlink" title="4. 变量名与作用域绑定表"></a>4. 变量名与作用域绑定表</h3><p>​	Python 变量本质上被存储在“作用域的命名空间”中，比如：</p>
<ul>
<li>函数体内：使用 <code>locals()</code> 获取当前局部变量绑定表。</li>
<li>模块中：使用 <code>globals()</code> 获取当前全局变量绑定表。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    y = <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">locals</span>())  <span class="comment"># &#123;&#x27;y&#x27;: 2&#125;</span></span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>()[<span class="string">&#x27;x&#x27;</span>])  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-小心变量名只是“引用”的问题"><a href="#5-小心变量名只是“引用”的问题" class="headerlink" title="5. 小心变量名只是“引用”的问题"></a>5. 小心变量名只是“引用”的问题</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">lst</span>):</span><br><span class="line">    lst.append(<span class="number">999</span>)</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">foo(a)</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># [1, 2, 3, 999]</span></span><br></pre></td></tr></table></figure>

<p>​	这里函数 <code>foo</code> 并没有复制列表，而是直接操作了原列表对象，因为变量名 <code>lst</code> 和 <code>a</code> 都指向了同一个列表对象。</p>
<hr>
<h3 id="6-Python-中变量与-C-语言的区别"><a href="#6-Python-中变量与-C-语言的区别" class="headerlink" title="6. Python 中变量与 C 语言的区别"></a>6. Python 中变量与 C 语言的区别</h3><table>
<thead>
<tr>
<th>特点</th>
<th>Python</th>
<th>C 语言</th>
</tr>
</thead>
<tbody><tr>
<td>变量是什么</td>
<td>名字到对象的引用</td>
<td>内存位置（存值的容器）</td>
</tr>
<tr>
<td>修改变量值</td>
<td>重新绑定引用</td>
<td>修改内存中的内容</td>
</tr>
<tr>
<td>指针</td>
<td>没有，自动引用计数</td>
<td>有明确地址和指针操作</td>
</tr>
<tr>
<td>变量作用域</td>
<td>本质是命名空间（字典）</td>
<td>基于栈结构</td>
</tr>
</tbody></table>
<hr>
<h3 id="7-图示理解：变量名的绑定"><a href="#7-图示理解：变量名的绑定" class="headerlink" title="7. 图示理解：变量名的绑定"></a>7. 图示理解：变量名的绑定</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = 10</span><br><span class="line">b = a</span><br></pre></td></tr></table></figure>

<p>内存图示意：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a ----</span><br><span class="line">       \</span><br><span class="line">        ---&gt; [对象：10]</span><br><span class="line">       /</span><br><span class="line">b ----</span><br></pre></td></tr></table></figure>

<p>如果执行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>那么图就变为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a ----&gt; [对象：20]</span><br><span class="line">b ----&gt; [对象：10]</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h3><ul>
<li>Python 中的变量名只是<strong>标签</strong>，用来绑定对象的引用。</li>
<li>一个对象可以有多个变量名指向它（即多个“引用”）。</li>
<li>变量重新赋值的本质是“重新绑定引用”，而不是覆盖原值。</li>
<li>对象没有引用了，Python 会通过垃圾回收机制自动释放它。</li>
</ul>
<h2 id="07-Singleton"><a href="#07-Singleton" class="headerlink" title="07. Singleton"></a>07. Singleton</h2><h3 id="1-目的"><a href="#1-目的" class="headerlink" title="1. 目的"></a>1. 目的</h3><p>​	单例模式的根本目的就是要让一个类只能创造出一个对象。可以借助下述代码理解，我们希望 print 的结果为 True：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">p1 = Person()</span><br><span class="line">p2 = Person()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p1 <span class="keyword">is</span> p2) <span class="comment"># wish output: True</span></span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>​	实际应用场景：</p>
<ul>
<li>工厂对象</li>
<li>数据库连接池对象</li>
<li>任何其他想要所有人共享的对象</li>
</ul>
<h3 id="2-Decorator实现单例模式（1）"><a href="#2-Decorator实现单例模式（1）" class="headerlink" title="2. Decorator实现单例模式（1）"></a>2. Decorator实现单例模式（1）</h3><p>​	单例模式的实现有很多种方式，首先第一种我们可以用装饰器来实现。还是先看代码然后再讲解：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 装饰器实现单例模式(1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">singleton</span>(<span class="params">cls</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">hasattr</span>(cls,<span class="string">&#x27;__instance&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getattr</span>(cls,<span class="string">&#x27;__instance&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        obj = cls(*args, **kwargs)</span><br><span class="line">        <span class="built_in">setattr</span>(cls, <span class="string">&#x27;__instance&#x27;</span>, obj)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">p1 = Person()</span><br><span class="line">p2 = Person()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p1 <span class="keyword">is</span> p2)</span><br></pre></td></tr></table></figure>

<p>​	如果你熟悉装饰器的话，看到这个结构应该会很熟悉。整段代码的核心逻辑在 <code>wrapper</code> 函数中：</p>
<ul>
<li>首先判断类是否有 <code>__instance</code> 这个属性；</li>
<li>如果有，直接返回它；</li>
<li>如果没有，就创建实例对象并绑定到类属性上；</li>
<li>然后返回这个对象。</li>
</ul>
<p>​	这样，第一次调用创建对象时会保存一个实例，后面无论调用多少次，返回的始终是最早创建的那一个。</p>
<p>​	我们不妨模拟一下下面的情景：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">p1 = Person()</span><br><span class="line">p2 = Person()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p1 <span class="keyword">is</span> p2)</span><br></pre></td></tr></table></figure>

<p>​	首先我使用 <code>Person</code> 创建了 <code>p1</code> 这个实例，那么执行这一行代码的时候，<code>Person</code> 就会传入 <code>singleton</code> 函数，然后进入 <code>wrapper</code>，发现自己没有 <code>__instance</code> 这个属性，于是创建了一个 <code>__instance</code> ，然后退出。接着会到创建 <code>p2</code> 对象这一步，同样进入到了 <code>wrapper</code> 函数内部，发现 <code>Person</code> 类中是有一个 <code>__instance</code>  属性的，于是直接把这个属性的值返回，那这个  <code>__instance</code> 的值是什么呢？很显然，就是刚才创建的 <code>p1</code> 对象。那么也就是说，第二次用 <code>Person</code> 类创建的对象和第一次的完全一样，也就实现了单例模式。执行代码，发现输出的结果的确是 <code>True</code>，再次佐证这一点。</p>
<h3 id="3-Decorator实现单例模式（2）"><a href="#3-Decorator实现单例模式（2）" class="headerlink" title="3. Decorator实现单例模式（2）"></a>3. Decorator实现单例模式（2）</h3><p>​	第二种方式本质相同，但关键差别在于：<strong>保存单例的地方变了</strong>，不是放在类的属性里，而是放在装饰器自身的闭包变量中：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. 装饰器实现单例模式(2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">singleton</span>(<span class="params">cls</span>):</span><br><span class="line">    _instance = &#123;&#125;</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">in</span> _instance:</span><br><span class="line">            <span class="keyword">return</span> _instance[cls]</span><br><span class="line">        obj = cls(*args, **kwargs)</span><br><span class="line">        _instance[cls] = obj</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">p1 = Person()</span><br><span class="line">p2 = Person()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p1 <span class="keyword">is</span> p2)</span><br></pre></td></tr></table></figure>

<p>​	你可能会想，<code>_instance</code> 是局部变量，<code>wrapper</code> 执行完怎么不会消失？这就牵涉到 <strong>闭包</strong> 的知识了：</p>
<blockquote>
<p><strong>闭包的一个重要特性就是可以“捕获”其外围函数的局部变量，使得这些变量不会随着函数结束而被释放，而是持续存在于返回的函数对象中。</strong></p>
</blockquote>
<p>​	所以 <code>_instance</code> 是“持久”的。每次调用 <code>Person()</code>，实际运行的都是 <code>wrapper()</code>，而 <code>_instance</code> 始终保存在这个闭包中。</p>
<p>​	另外我在写这段代码的时候还有一个疑问，就是为什么 <code>_instance</code> 不用元组呢？</p>
<p>​	确实，如果只是装饰一个类，只用元组或列表保存一个实例也没问题，比如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">singleton</span>(<span class="params">cls</span>):</span><br><span class="line">    _instance = []</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> _instance:</span><br><span class="line">            <span class="keyword">return</span> _instance[<span class="number">0</span>]</span><br><span class="line">        obj = cls(*args, **kwargs)</span><br><span class="line">        _instance.append(obj)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<p>​	但问题来了，如果我想让多个类都能使用这个装饰器怎么办？我们来看看下面这个例子：</p>
<hr>
<p><strong>多类使用时字典的优势</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">singleton</span>(<span class="params">cls</span>):</span><br><span class="line">    _instance = &#123;&#125;  <span class="comment"># 记录每个被装饰的类各自的实例</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> _instance:</span><br><span class="line">            _instance[cls] = cls(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> _instance[cls]</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">a1 = A()</span><br><span class="line">a2 = A()</span><br><span class="line">b1 = B()</span><br><span class="line">b2 = B()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a1 <span class="keyword">is</span> a2)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(b1 <span class="keyword">is</span> b2)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(a1 <span class="keyword">is</span> b1)  <span class="comment"># False，不同类各自拥有独立的单例</span></span><br></pre></td></tr></table></figure>

<p>​	如果不用字典，只能保存一个实例，显然就没法做到多个类共享装饰器的情况下还能保证“各自单例”。<strong>这就是使用字典的真正价值所在。</strong></p>
<p>​	<strong>最后两种方式的话，后者更加推荐，因为复用性高、无侵入、逻辑清晰，而前者虽然结构简单但是侵入性强。</strong></p>
<h3 id="4-MetaClass实现单例模式"><a href="#4-MetaClass实现单例模式" class="headerlink" title="4. MetaClass实现单例模式"></a>4. MetaClass实现单例模式</h3><h2 id="08-MetaClass"><a href="#08-MetaClass" class="headerlink" title="08. MetaClass"></a>08. MetaClass</h2><p>​	<code>metaclass</code>，元类，这个概念比较陌生，之前听得更多的是 <code>superclass</code>，父类。所以 <code>metaclass</code> 到底是个什么东西，它和 <code>superclass</code> 又有什么区别呢？</p>
<hr>
<h3 id="1-object-和-type"><a href="#1-object-和-type" class="headerlink" title="1. object 和 type"></a>1. object 和 type</h3><p>​	讲 <code>metaclass</code> 之前，我们首先要对 <code>object</code> 和 <code>type</code> 这两个很特殊的类有一个初步认识。在 Python 中，<code>object</code> 和 <code>type</code> 是最核心的两个内建类，它们构成了 Python 类型系统的基础。</p>
<p><code>object</code> 是所有类的祖先，特点有：</p>
<ul>
<li><strong>所有类默认继承自 <code>object</code></strong>（即使你没写出来）。</li>
<li><code>object</code> 提供了一些基础的方法，比如 <code>__str__</code>、<code>__eq__</code>、<code>__hash__</code> 等。</li>
<li>是<strong>所有实例的基类</strong>。</li>
</ul>
<p><code>type</code> 是所有类的类型，特点有：</p>
<ul>
<li>所有 <strong>类</strong>（class）都是 <code>type</code> 的实例。</li>
<li>换句话说：<strong>类是 <code>type</code> 的实例，实例是类的实例。</strong></li>
<li><code>type</code> 本身也是一个类，是元类（metaclass）的默认实现。</li>
</ul>
<p><code>type</code> 是一个特殊的元类，它是自己的实例<code>（type(type) == type）</code>，而 <code>object</code> 是所有类的最终基类，没有父类。</p>
<p>下面用一段程序来印证上述内容：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>.__class__)     <span class="comment"># &lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">object</span>.__class__)   <span class="comment"># &lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>.__bases__)     <span class="comment"># (&lt;class &#x27;object&#x27;&gt;,)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">object</span>.__bases__)   <span class="comment"># ()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他内建类的元类和基类</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>.__class__)      <span class="comment"># &lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">float</span>.__class__)    <span class="comment"># &lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>.__class__)     <span class="comment"># &lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>.__bases__)      <span class="comment"># (&lt;class &#x27;object&#x27;&gt;,)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">float</span>.__bases__)    <span class="comment"># (&lt;class &#x27;object&#x27;&gt;,)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>.__bases__)     <span class="comment"># (&lt;class &#x27;int&#x27;&gt;,)</span></span><br></pre></td></tr></table></figure>

<p>​	有关 <code>object</code> 和 <code>type</code>，如果是刚接触确实不好理解它们的关系，这里推荐一个视频可以很好的帮助理解。后面的 <code>metaclass</code> 如果想要理解透彻的话，这两个概念是一定要分清楚的。</p>
<p>​	推荐视频：<br> <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1M7411k7ib/?spm_id_from=333.337.search-card.all.click&vd_source=a3a7b6035d802044a698f0b0e846a493">Python-面向对象-三大特性-type和object - 哔哩哔哩</a></p>
<hr>
<h3 id="2-metaclass-概述"><a href="#2-metaclass-概述" class="headerlink" title="2. metaclass 概述"></a>2. metaclass 概述</h3><p>什么是 <code>metaclass</code>？其实前面的 <code>type</code> 就是一个 <code>metaclass</code>，它是所有类默认的元类。简单一句话总结就是：</p>
<blockquote>
<p><strong>metaclass 是“创建类的类”</strong>。</p>
</blockquote>
<p>也就是说我们在创建一个类的时候，实际上是通过 metaclass 的 <code>__new__()</code> 方法来构造这个类对象的。</p>
<p>来看一个例子：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义 metaclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">mcs, name, bases, namespace, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Creating class: <span class="subst">&#123;name&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="comment"># 调用 type.__new__ 真正创建类</span></span><br><span class="line">        cls = <span class="built_in">super</span>().__new__(mcs, name, bases, namespace)</span><br><span class="line">        <span class="comment"># 在生成的类上动态加属性</span></span><br><span class="line">        cls.freedom = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> cls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建类时指定 metaclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="built_in">object</span>, metaclass=Human):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Person.freedom)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p>我们看到，在创建 <code>Person</code> 类时指定了 <code>metaclass=Human</code>，这意味着：</p>
<ul>
<li><strong>Python 在构建 <code>Person</code> 这个类的时候，并不是使用默认的 <code>type</code>，而是使用自定义的 <code>Human</code> 来创建它。</strong></li>
<li>换句话说，<code>Person</code> 是 <code>Human</code> 的实例，就像 <code>p = Person()</code> 创建的是实例一样。</li>
</ul>
<p>那 <code>Human</code> 是如何创建 <code>Person</code> 类的呢？答案是通过调用 <code>Human.__new__()</code> 方法来控制类的创建流程。因为 <code>Human</code> 是一个 <code>metaclass</code>，而 <code>metaclass</code> 的职责就是生成类对象。</p>
<p>接下来我们注意到，<code>Human</code> 是继承自内建的 <code>type</code>，这意味着：</p>
<ul>
<li><code>Human</code> 本质上还是一个 <code>type</code> 的子类；</li>
<li>在 <code>Human.__new__()</code> 中我们调用了 <code>super().__new__()</code>，也就是调用了 <code>type.__new__()</code>；</li>
<li>所以尽管我们自定义了一个元类 <code>Human</code>，它本质上仍然建立在 Python 默认机制 <code>type</code> 的基础之上。</li>
</ul>
<p>还需要特别指出的是，这里你可以看到我的 <code>__new__()</code> 函数接受了四个位置参数 <code>mcs</code>、<code>name</code>、<code>bases</code>、<code>namespace</code>，这是因为元类的 <code>__new__</code> 方法（继承自 <code>type</code>）需要这些参数，而后面的 <code>**kwargs</code> 是为了动态接收额外的参数，比如类的属性。</p>
<p>输出结果表明，<code>Person</code> 这个类确实是被 <code>Human</code> 创建的。同时 <code>Person.freedom == True</code>，说明我们在 <code>__new__()</code> 中添加的类属性成功生效。</p>
<p>另外补充说明一下程序中的参数：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">mcs, name, bases, namespace, **kwargs</span>):</span><br><span class="line">        <span class="comment"># name: 类名（比如 &#x27;Person&#x27;）</span></span><br><span class="line">        <span class="comment"># bases: 父类组成的元组（比如 (&lt;class &#x27;object&#x27;&gt;,)）</span></span><br><span class="line">        <span class="comment"># namespace: 类体内定义的属性和方法构成的字典</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>保留 <code>**kwargs</code> 是为了支持一些额外的 class-level 参数（例如 Django ORM 中会传一些元参数如 <code>db_table=&#39;user&#39;</code> 给元类），否则会报错。</p>
<hr>
<h3 id="3-superclass-与-metaclass-的区别"><a href="#3-superclass-与-metaclass-的区别" class="headerlink" title="3. superclass 与 metaclass 的区别"></a>3. superclass 与 metaclass 的区别</h3><table>
<thead>
<tr>
<th>项目</th>
<th>superclass（父类）</th>
<th>metaclass（元类）</th>
</tr>
</thead>
<tbody><tr>
<td>作用</td>
<td>控制实例的行为</td>
<td>控制类的创建过程</td>
</tr>
<tr>
<td>继承方式</td>
<td><code>class A(B): ...</code></td>
<td><code>class A(..., metaclass=M): ...</code></td>
</tr>
<tr>
<td>运行阶段</td>
<td>创建实例时起作用</td>
<td>创建类时起作用</td>
</tr>
<tr>
<td>调用方法</td>
<td>调用父类的方法</td>
<td>调用 <code>__new__</code> 或 <code>__init__</code></td>
</tr>
<tr>
<td>实例关系</td>
<td>实例是类的实例</td>
<td>类是元类的实例</td>
</tr>
</tbody></table>
<p>一句话总结：</p>
<blockquote>
<p>父类决定“实例能做什么”，元类决定“类长成什么样”。</p>
</blockquote>
<hr>
<h3 id="4-自定义-metaclass"><a href="#4-自定义-metaclass" class="headerlink" title="4. 自定义 metaclass"></a>4. 自定义 metaclass</h3><p>​	前面在 <code>metaclass</code> 中的概述中已经自定义过 <code>metaclass</code> 了，但是这有一个新的问题，就是我要用 <code>Human</code> 给 <code>Person</code> 这个类定义一些类属性，我是写死在 <code>Human</code> 的 <code>__new__()</code> 函数中的，那这个时候，如果我说我想在创建 <code>Person</code> 的时候多定义几个类属性，难道我要去手动修改 <code>metaclass</code> 中的 <code>__new__()</code> 方法吗？这显然不符合我们的习惯。</p>
<p>​	那么想要解决这个问题，就需要自定义一个可以支持动态参数的 <code>metaclass</code> 了。那么用什么支持动态参数呢？可以使用 <code>**kwargs</code>。注意这里的 <code>kwargs</code> 只是只是一个名字，你可以管他叫其他任意名字，但是一般来说都会叫这个名字，这是业内约定俗成的。其实我们前面已经写了 <code>**kwargs</code> 用来接收多个关键字参数，只是没有使用到它，要使用它来实现支持动态参数的 <code>metaclass</code> 只需要加一个遍历即可：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">mcs, name, bases, namespace, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Creating class:<span class="subst">&#123;mcs&#125;</span>&#x27;</span>)</span><br><span class="line">        class_ = <span class="built_in">super</span>().__new__(mcs, name, bases, namespace)</span><br><span class="line">        <span class="keyword">if</span> kwargs:</span><br><span class="line">            <span class="keyword">for</span> key, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line">                <span class="built_in">setattr</span>(class_, key, value)</span><br><span class="line">        <span class="keyword">return</span> class_</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="built_in">object</span>, metaclass=Animal, country=<span class="string">&#x27;China&#x27;</span>, freedom=<span class="literal">True</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Dog.country)</span><br><span class="line"><span class="built_in">print</span>(Dog.freedom)</span><br><span class="line"><span class="comment"># Creating class:&lt;class &#x27;__main__.Animal&#x27;&gt;</span></span><br><span class="line"><span class="comment"># China</span></span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p>​	可以看到，增加一个遍历之后就可以实现在创建类的时候设置多个类属性。需要注意的是，<code>__new__</code> 可以不加装饰器(因为 Python 会将其视为普通方法（非绑定方法），能正确接收参数。)或使用 <code>@staticmethod</code>，但不能使用 <code>@classmethod</code> ，因为它会导致参数绑定错误，而 <code>@staticmethod</code> 或不加装饰器能正确接收 Python 传递的所有参数。</p>
<hr>
<h3 id="5-metaclass-实际用途"><a href="#5-metaclass-实际用途" class="headerlink" title="5. metaclass 实际用途"></a>5. metaclass 实际用途</h3><p><strong>元类（metaclass）简单总结</strong></p>
<ol>
<li><strong>本质</strong><ul>
<li>元类是“创建类的类”，决定类对象在内存中的构造方式。</li>
<li>触发点：Python 在执行 <code>class X:</code> 时会调用元类生成最终的类对象。</li>
</ul>
</li>
<li><strong>最常见的 5 类用途</strong><ol>
<li><strong>自动注册子类</strong>：插件、策略或模型注册器无需手动登记。</li>
<li><strong>类级校验／约束</strong>：ORM 或序列化框架强制字段、方法存在。</li>
<li><strong>批量注入逻辑</strong>：统一给类方法加日志、权限、缓存等装饰器。</li>
<li><strong>设计模式实现</strong>：如单例（Singleton）在 <code>__call__</code> 中控制实例化。</li>
<li><strong>接口&#x2F;规范检查</strong>：大型项目里确保所有子类实现指定 API。</li>
</ol>
</li>
<li><strong>什么时候值得用</strong><ul>
<li><strong>项目规模较大</strong>、同类型类很多，需要<strong>统一行为或约束</strong>。</li>
<li>普通装饰器或继承无法优雅解决时。</li>
<li>需要在<strong>类定义阶段</strong>做检查或修改，而非运行时。</li>
</ul>
</li>
<li><strong>不建议使用的场景</strong><ul>
<li>仅为炫技；小脚本或简单业务逻辑。</li>
<li>可以用类装饰器、抽象基类（ABC）轻松做到的，就别上元类。</li>
<li>团队成员对元类理解不足，维护成本会显著升高。</li>
</ul>
</li>
</ol>
<blockquote>
<p>一句话总结：<strong>元类用于在“类生成时”集中做自动注册、校验或注入逻辑，适合复杂框架或插件体系，小项目别用。</strong></p>
</blockquote>
<h2 id="09-并发编程"><a href="#09-并发编程" class="headerlink" title="09. 并发编程"></a>09. 并发编程</h2><h3 id="1-thread"><a href="#1-thread" class="headerlink" title="1. thread"></a>1. thread</h3><h4 id="1-线程与进程"><a href="#1-线程与进程" class="headerlink" title="(1) 线程与进程"></a>(1) 线程与进程</h4><p>​	线程和进程是一个很大的话题，如果要展开讲的话有很多内容。在了解并发编程之前最好将这两个概念理解好，我这里就不展开聊了（当时操作系统学的其实我现在也忘得差不多了，之后要恶补一下）。但是起码我们需要了解：<strong>进程是资源分配的基本单位，而线程是 CPU 调度和执行的基本单位。每个进程至少包含一个线程（主线程），线程共享进程的内存资源，因此线程间通信比进程更高效。</strong></p>
<h4 id="2-创建线程"><a href="#2-创建线程" class="headerlink" title="(2) 创建线程"></a>(2) 创建线程</h4><p>​	接下来我们先看一段程序，默认程序运行在主线程中：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;task start&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;task end&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">task()</span><br><span class="line">task()</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">task end</span><br><span class="line">task start</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">task end</span><br></pre></td></tr></table></figure>

<p>​	可以看到，如果我两次执行这个 <code>task</code> 函数，那么程序其实会先执行完一遍 <code>task</code> 然后再执行一遍，无论执行多少次都是一样的结果。这个效率其实是很低的。一般来说，如果前后执行的两个函数之间没有什么依赖关系的话，是可以一起执行的，这样可以大大提升效率。那么应该怎么实现呢？</p>
<p>​	想要实现多个线程并发执行，就需要用到 <code>Thread</code> 类，用这个类来创建对象实现并发，如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thread1 = Thread(target=task)</span><br><span class="line">thread2 = Thread(target=task)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动线程</span></span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待线程完成</span></span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br></pre></td></tr></table></figure>

<p>​	我们在程序中引入了一个 <code>Thread</code> 类，然后将 <code>task</code> 作为 <code>target</code> 的参数传入，就实现了一个线程的创建，之后使用 start 方法启动线程。然后如果我想等到线程运行结束，那么就要使用 <code>join</code> 方法。关于为什么要叫 <code>join</code>，其实可以这么理解：我在主线程下创建了一个子线程，这是一个分离的过程，那等到这个子线程运行完成之后，就需要合并或者说汇合进主线程，所以叫 <code>join</code>。那么通过这样一个 <code>Thread</code> 类，就可以实现多线程编程了。我们来看看程序运行结果：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">task start</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line">task start</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">task end</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">task end</span><br></pre></td></tr></table></figure>

<p>​	实际上每次运行的结果都会不一样，因为我们无法控制线程运行的先后顺序。</p>
<h4 id="3-给线程传递参数"><a href="#3-给线程传递参数" class="headerlink" title="(3) 给线程传递参数"></a>(3) 给线程传递参数</h4><p>​	随之而来的又有一个问题，如果我的 <code>task</code> 有传参呢？其实这个问题也非常好解决，<code>Thread</code> 提供了一个 <code>args</code> 参数来实现传参，需要注意的是 <code>args</code> 接收一个 <code>tuple</code>。具体代码如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">cnt</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;task start&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(cnt):</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;task end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thread1 = Thread(target=task, args=(<span class="number">10</span>,))</span><br><span class="line">thread2 = Thread(target=task, args=(<span class="number">5</span>,))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动线程</span></span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待线程完成</span></span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">task start</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line">7task start</span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="number">29</span></span><br><span class="line">task end</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span></span><br><span class="line">task end</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-thread-advanced"><a href="#2-thread-advanced" class="headerlink" title="2. thread advanced"></a>2. thread advanced</h3><h4 id="1-daemon-thread"><a href="#1-daemon-thread" class="headerlink" title="(1) daemon thread"></a>(1) daemon thread</h4><p>​	守护线程就是在定义的时候，设置了参数 <code>daemon=True</code>，参考下面程序的第 8 行。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 守护线程  daemon=True</span></span><br><span class="line"><span class="comment"># 这里用继承 Thread 的方式自定义了一个线程类</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span>(<span class="title class_ inherited__">Thread</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name: <span class="built_in">str</span>, count: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name=name, daemon=<span class="literal">True</span>)</span><br><span class="line">        <span class="variable language_">self</span>.count = count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.count):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;self.name&#125;</span> - <span class="subst">&#123;n&#125;</span>\n&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            time.sleep(<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t_1 = MyThread(<span class="string">&#x27;A&#x27;</span>, <span class="number">10</span>)</span><br><span class="line">t_2 = MyThread(<span class="string">&#x27;B&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">t_1.start()</span><br><span class="line">t_2.start()</span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># A - 0</span></span><br><span class="line"><span class="comment"># B - 0</span></span><br></pre></td></tr></table></figure>

<p>​	可以看到，输出结果是 A 和 B 线程各自创建了一个数，就只有一个数。如果我们不设置 <code>daemon</code>（默认为 <code>False</code>），那么这两个线程会输出完所有的数字。</p>
<p>​	所以什么是守护线程呢？我们运行的程序叫做主线程，设置<code>daemon=True</code> 的叫做守护线程，没有设置的叫做非守护线程。那么这三者会有这样一种关系：<strong>主线程运行完最后一行命令之后，如果非守护线程还没有执行完，那么主线程会等待非守护线程执行完才会结束；主线程不会等待守护线程，只要主线程结束，守护线程就结束。</strong></p>
<p>​	所以上面的程序输出只有两个是因为：主线程在启动完线程 A 和 B 之后，马上会结束，而这个空挡很短，A 和 B 在这个时间内只能输出一个数，随后主进程结束了，守护进程也就马上结束了。如果在程序的最后加一行<code>time.sleep(1)</code>，让主进程晚 1 秒结束，就可以看到进程 A 和 B 的完整输出了，这一点也可以验证前面所说的。</p>
<h4 id="2-线程安全队列"><a href="#2-线程安全队列" class="headerlink" title="(2) 线程安全队列"></a>(2) 线程安全队列</h4><p>​	<code>queue</code> 模块中的 <code>Queue</code> 类提供了线程安全队列功能：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">queue.put(item, block=<span class="literal">False</span>) <span class="comment"># item 表示需要插入的数据，block=False 表示不允许阻塞，如果队列满了之后还想 put 数据，会抛出一个异常</span></span><br><span class="line">queue.put(item, timeout=<span class="number">3</span>) <span class="comment"># timeout 则表示如果 3 秒之内 put 不了数据，会抛出一个异常</span></span><br><span class="line">queue.get(block=<span class="literal">True</span>) <span class="comment"># 这里和上面的一样，队列为空的时候触发</span></span><br><span class="line">queue.get(timeout=<span class="number">10</span>) <span class="comment"># 这里和上面的一样，队列为空的时候触发</span></span><br><span class="line">queue.qsize() <span class="comment"># 设置队列大小</span></span><br><span class="line">queue.empty() <span class="comment"># 检测队列是否为空</span></span><br><span class="line">queue.full() <span class="comment"># 检测队列是否为满</span></span><br></pre></td></tr></table></figure>

<p>​	<strong>线程安全</strong>是指在多线程环境下，当多个线程同时访问或修改共享数据时，程序仍能保证其<strong>正确性、数据一致性，并且不会导致不可预测的行为或错误</strong>。</p>
<p>​	具体 <code>Queue类</code> 是怎么可以做到提供线程安全，我们可以看下面生产者消费者的实例。</p>
<h4 id="3-生产者消费者线程实例"><a href="#3-生产者消费者线程实例" class="headerlink" title="(3) 生产者消费者线程实例"></a>(3) 生产者消费者线程实例</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgProducer</span>(<span class="title class_ inherited__">Thread</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name: <span class="built_in">str</span>, count: <span class="built_in">int</span>, q: Queue</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name=name)</span><br><span class="line">        <span class="variable language_">self</span>.count = count <span class="comment"># 定义 Producer 要生产多少个数据</span></span><br><span class="line">        <span class="variable language_">self</span>.q = q</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.count):</span><br><span class="line">            msg = <span class="string">f&#x27;<span class="subst">&#123;self.name&#125;</span> -- <span class="subst">&#123;n&#125;</span>&#x27;</span></span><br><span class="line">            <span class="variable language_">self</span>.q.put(msg, block=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgConsumer</span>(<span class="title class_ inherited__">Thread</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name: <span class="built_in">str</span>, q: Queue</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name=name, daemon=<span class="literal">True</span>)</span><br><span class="line">        <span class="variable language_">self</span>.q = q</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            msg = <span class="variable language_">self</span>.q.get(block=<span class="literal">True</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;self.name&#125;</span> -- <span class="subst">&#123;msg&#125;</span>\n&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">q = Queue(<span class="number">3</span>)</span><br><span class="line">threads = <span class="built_in">list</span>()</span><br><span class="line"><span class="comment"># 创建Producer</span></span><br><span class="line">threads.append(MsgProducer(<span class="string">&#x27;ProducerA&#x27;</span>, <span class="number">10</span>, q))</span><br><span class="line">threads.append(MsgProducer(<span class="string">&#x27;ProducerB&#x27;</span>, <span class="number">10</span>, q))</span><br><span class="line">threads.append(MsgProducer(<span class="string">&#x27;ProducerC&#x27;</span>, <span class="number">10</span>, q))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Consumer</span></span><br><span class="line">threads.append(MsgConsumer(<span class="string">&#x27;ConsumerA&#x27;</span>, q))</span><br><span class="line">threads.append(MsgConsumer(<span class="string">&#x27;ConsumerB&#x27;</span>, q))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 Producer 和 Consumer 线程</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待一秒，给 Consumer 一点时间，这是为了检验是否能产生 30 条数据</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	在这个程序中，我定义了一个 <code>Producer</code> 类和一个 <code>Consumer</code> 类，<code>Producer</code> 是非守护线程，<code>Consumer</code> 是守护线程。程序的具体细节我就不说了，这个理解了前面讲的内容之后仔细看看也可以理解。</p>
<p>​	我想讲一讲为什么这个程序可以实现线程安全。我特意设置了队列 <code>q</code> 的长度为 3，这是为了制造出阻塞，如果设计太长了就不会有这个问题了。然后我把 <code>Producer</code> 和 <code>Consumer</code> 的 <code>put</code> 和 <code>get</code> 操作都设置为了 <code>block=True</code>，也就是说：队列填满的时候，<code>Producer</code> 会阻塞等待，等待 <code>Consumer</code> 从队列中拿走数据，一旦发现队列没满，就会继续 <code>put</code> 数据；队列空的时候，<code>Consumer</code> 也会阻塞等待，直到 <code>Producer</code> 往其中 <code>put</code> 数据了，才会继续读。也就是说，整个过程中，数据不会丢，最多就是发生阻塞然后等待一会，这就保证了线程的安全。</p>
<hr>
<h3 id="3-ThreadLock"><a href="#3-ThreadLock" class="headerlink" title="3. ThreadLock"></a>3. ThreadLock</h3><p>​	先来看下面一段程序：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 线程锁</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">name: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span> -- round<span class="subst">&#123;i&#125;</span> -- step1\n&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span> -- round<span class="subst">&#123;i&#125;</span> -- step2\n&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span> -- round<span class="subst">&#123;i&#125;</span> -- step3\n&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)  <span class="comment"># 为了将线程之间的随机性凸显出来</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1 = Thread(target=task, args=(<span class="string">&#x27;A&#x27;</span>,))</span><br><span class="line">t2 = Thread(target=task, args=(<span class="string">&#x27;B&#x27;</span>,))</span><br><span class="line">t3 = Thread(target=task, args=(<span class="string">&#x27;C&#x27;</span>,))</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t3.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># A -- round0 -- step1</span></span><br><span class="line"><span class="comment"># A -- round0 -- step2</span></span><br><span class="line"><span class="comment"># A -- round0 -- step3</span></span><br><span class="line"><span class="comment"># B -- round0 -- step1</span></span><br><span class="line"><span class="comment"># B -- round0 -- step2</span></span><br><span class="line"><span class="comment"># B -- round0 -- step3</span></span><br><span class="line"><span class="comment"># C -- round0 -- step1</span></span><br><span class="line"><span class="comment"># C -- round0 -- step2</span></span><br><span class="line"><span class="comment"># C -- round0 -- step3</span></span><br><span class="line"><span class="comment"># B -- round1 -- step1</span></span><br><span class="line"><span class="comment"># A -- round1 -- step1</span></span><br><span class="line"><span class="comment"># A -- round1 -- step2</span></span><br><span class="line"><span class="comment"># B -- round1 -- step2</span></span><br><span class="line"><span class="comment"># B -- round1 -- step3</span></span><br><span class="line"><span class="comment"># C -- round1 -- step1</span></span><br><span class="line"><span class="comment"># A -- round1 -- step3</span></span><br><span class="line"><span class="comment"># C -- round1 -- step2</span></span><br><span class="line"><span class="comment"># C -- round1 -- step3</span></span><br></pre></td></tr></table></figure>

<p>​	从运行结果不难发现，同一个 <code>round</code> 下会被其他的线程给插进来，比如说进程 C 的 round 1在执行完第一步之后，被进程 A 插入了进来先执行了 A 的 step3，但是我们运行程序的时候往往是希望一个进程在某一个 round 内应该是能够一次性完成的，不希望被其他进程插队，也就是说我们希望一个 <code>round</code> 中的 step1 step2 step3 一起执行，那么这个该如何解决呢？</p>
<p>​	答案是，可以在这个 <code>round</code> 之前上锁，在这个 <code>round</code> 之后释放锁。那么该如何上锁呢？其实这个操作也很简单，只需要在 <code>thread</code> 中引入 <code>Lock</code> 就可以了，然后定义一个全局变量，在 <code>round</code> 开始的时候 <code>acquire</code>，结束的时候 <code>release</code>就可以了：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 线程锁</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock</span><br><span class="line"></span><br><span class="line">task_lock = Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">name: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="keyword">global</span> task_lock</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        task_lock.acquire()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span> -- round<span class="subst">&#123;i&#125;</span> -- step1\n&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span> -- round<span class="subst">&#123;i&#125;</span> -- step2\n&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span> -- round<span class="subst">&#123;i&#125;</span> -- step3\n&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        task_lock.release()</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)  <span class="comment"># 为了将线程之间的随机性凸显出来</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1 = Thread(target=task, args=(<span class="string">&#x27;A&#x27;</span>,))</span><br><span class="line">t2 = Thread(target=task, args=(<span class="string">&#x27;B&#x27;</span>,))</span><br><span class="line">t3 = Thread(target=task, args=(<span class="string">&#x27;C&#x27;</span>,))</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t3.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	这样之后无论如何运行，一个 <code>round</code> 之内的三步一定是一起执行的。</p>
<hr>
<h3 id="4-ThreadPool"><a href="#4-ThreadPool" class="headerlink" title="4. ThreadPool"></a>4. ThreadPool</h3><p>​	接下来引入线程池的概念。首先我们需要知道以下几点：</p>
<ul>
<li><strong>线程的创建和销毁相对比较昂贵</strong></li>
<li><strong>频繁的创建和销毁线程不利于高性能</strong></li>
<li><strong>线程池是 Python 提供的便于线程管理和提高性能的工具</strong></li>
</ul>
<p>​	所以如果我们频繁地创建和销毁进程，其实性能会比较低，那这时候我们可以思考一个问题，我可不可以建一个线程池，开启几个线程之后就一直在那里等着不销毁，来任务了就拿出去一个线程，任务完成了就还回来呢？在 Python 中是提供了这样的一个包的，可以给我们直接使用。下面看一个例子：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 线程池</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">name: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span> -- step 1\n&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span> -- step 2\n&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;name&#125;</span> complete&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor() <span class="keyword">as</span> executor:</span><br><span class="line">    res1 = executor.submit(task, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    res2 = executor.submit(task, <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(res1.result())</span><br><span class="line">    <span class="built_in">print</span>(res2.result())</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor() <span class="keyword">as</span> executor:</span><br><span class="line">    results = executor.<span class="built_in">map</span>(task, [<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> results:</span><br><span class="line">        <span class="built_in">print</span>(r)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	这就是线程池最简单的应用了。<code>ThreadPoolExecutor()</code> 创建的实例支持以下方法：</p>
<ul>
<li>submit()</li>
<li>map()</li>
<li>shutdown()</li>
</ul>
<p>​	有关 <code>submit</code> 和 <code>map</code> 的相同点和不同的，上面的代码中就可以看出一些来。这两个方法的作用都是启用一个线程，不同的是 <code>submit</code> 每次都只能启动一个线程，而 <code>map</code> 可以对相同函数一次性传入多个参数。当多个线程都是相同的函数的时候，可以使用 <code>map</code> 方法，更加方便。</p>
<p>​	有关这两者的区别，下面还有一个表格来展示：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th><code>submit()</code></th>
<th><code>map()</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>调用方式</strong></td>
<td><code>future = pool.submit(func, *args, **kwargs)</code> —— 一次提交<strong>一个</strong>任务，返回 <code>Future</code> 对象</td>
<td><code>results = pool.map(func, iterable, timeout=None, chunksize=1)</code> —— 一次提交<strong>一批</strong>任务，返回<strong>惰性</strong>迭代器（内部批量创建 <code>Future</code>）</td>
</tr>
<tr>
<td><strong>结果顺序</strong></td>
<td>由你决定：• 可单独 <code>future.result()</code>• 或用 <code>concurrent.futures.as_completed</code> 按完成先后处理</td>
<td><strong>保证“输入顺序 &#x3D;&#x3D; 输出顺序”</strong>。不管谁先跑完，迭代器产出的结果按 <code>iterable</code> 原顺序排</td>
</tr>
<tr>
<td><strong>异常处理</strong></td>
<td>每个 <code>Future</code> 独立；调用 <code>future.result()</code> 时把线程里抛出的异常再抛给主线程</td>
<td>如果其中某个任务抛异常，<strong>整个 <code>map</code> 迭代器会在取到该结果时抛出</strong>，后续结果无法继续获取</td>
</tr>
<tr>
<td><strong>灵活度</strong></td>
<td>★★★★★ 可混用回调、<code>wait</code>、超时、取消等高级操作</td>
<td>★★☆☆☆ 主要适合“跑完就要结果”且对顺序有要求的批处理</td>
</tr>
<tr>
<td><strong>返回值类型</strong></td>
<td><code>Future</code>（或自己封装成列表&#x2F;字典）</td>
<td>惰性迭代器；通常立即用 <code>list()</code> 或 <code>for</code> 消耗</td>
</tr>
<tr>
<td><strong>典型场景</strong></td>
<td>• 需要<strong>流式</strong>处理（谁先完成先处理）• 需要单独超时、取消、回调• 需要把额外上下文传给回调</td>
<td>• 任务很多且<strong>不关心实时</strong>但要保持顺序（如大批量 I&#x2F;O 下载后统一写文件）• 想用“输入列表 → 输出列表”最少代码</td>
</tr>
</tbody></table>
<p>​	</p>
<p>​	至于 shutdown() 方法，它的作用是**告诉线程池：我不再提交新任务了，已经在跑或排队的任务全都按指定策略处理完，然后把线程统统回收。**那为什么我上面的函数并没有用到呢，是因为 <code>ThreadPoolExecutor</code>支持上下文管理器 <code>ContextManager</code>，会自动调用 <code>shutdown</code>。</p>
<hr>
<h3 id="5-MultiProcessing"><a href="#5-MultiProcessing" class="headerlink" title="5. MultiProcessing"></a>5. MultiProcessing</h3><p>​	首先来讲讲为什么需要有多进程吧。CPython 的 <strong>GIL（全局解释器锁）</strong> 保证任意时刻只有一个线程在执行字节码。CPU 密集型任务即使用多线程也只能“排队”跑，效率被锁住。多进程则各有独立解释器，<strong>每个进程在一个 CPU 核心上独立并行</strong>。同时现代CPU动辄 8核甚至几十核，多进程可以让每个核心都有活干，总用时≈单核耗时÷核心数，</p>
<p>​	Python 实现多进程编程也很简单，只需要使用 Python提供的包 <code>multiprocessing</code>中的 <code>Process</code> 类就可以了，下面用一段程序介绍多线程的使用方法以及观察多进程之间的差异：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">name: <span class="built_in">str</span>, count: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span> -- start&#x27;</span>)</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">        res += <span class="number">1</span></span><br><span class="line">    time.sleep(<span class="number">20000</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span> -- end <span class="subst">&#123;res&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_process_1</span>():</span><br><span class="line">    process = multiprocessing.Process(target=task, args=(<span class="string">&#x27;A&#x27;</span>, <span class="number">100</span>))</span><br><span class="line">    process.start()</span><br><span class="line">    process.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Main process over&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_process_2</span>():</span><br><span class="line">    args_list = [(<span class="string">&#x27;A&#x27;</span>, <span class="number">10</span>), (<span class="string">&#x27;B&#x27;</span>, <span class="number">20</span>), (<span class="string">&#x27;C&#x27;</span>, <span class="number">30</span>)]</span><br><span class="line">    process = [multiprocessing.Process(target=task, args=(name, count)) <span class="keyword">for</span> name, count <span class="keyword">in</span> args_list]</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> process:</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> process:</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start_process_2()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-ProcessPool"><a href="#6-ProcessPool" class="headerlink" title="6. ProcessPool"></a>6. ProcessPool</h3><p>​	和前面的 ThreadPool 一样，ProcessPool 的实现也是可以调用现有的包 ProcessPoolExecutor，调用方式几乎完全一致，下面用一段代码展示其用法，同时展示多线程和多进程的区别：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cpu_work</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10_000_00</span>):</span><br><span class="line">        total += math.sin(i) * math.cos(i)</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">N_WORKERS = <span class="number">8</span></span><br><span class="line">TASKS = [<span class="number">1</span>] * N_WORKERS</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 1. 多线程</span></span><br><span class="line">    start = time.perf_counter()</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=N_WORKERS) <span class="keyword">as</span> tp:</span><br><span class="line">        tp.<span class="built_in">map</span>(cpu_work, TASKS)</span><br><span class="line">    cost = time.perf_counter() - start</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;多线程耗时：<span class="subst">&#123;cost * <span class="number">1000</span>:<span class="number">.2</span>f&#125;</span>ms&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    start = time.perf_counter()</span><br><span class="line">    cpu_work(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;单线程耗时：<span class="subst">&#123;(time.perf_counter() - start) * <span class="number">1000</span>:<span class="number">.2</span>f&#125;</span>ms&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 多进程</span></span><br><span class="line">    start = time.perf_counter()</span><br><span class="line">    <span class="keyword">with</span> ProcessPoolExecutor(max_workers=N_WORKERS) <span class="keyword">as</span> pp:</span><br><span class="line">        pp.<span class="built_in">map</span>(cpu_work, TASKS)</span><br><span class="line">    cost = time.perf_counter() - start</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;多进程耗时：<span class="subst">&#123;cost * <span class="number">1000</span>:<span class="number">.2</span>f&#125;</span>ms&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多线程耗时：1328.57ms</span></span><br><span class="line"><span class="comment"># 单线程耗时：162.31ms</span></span><br><span class="line"><span class="comment"># 多进程耗时：886.85ms</span></span><br></pre></td></tr></table></figure>

<p>​	这里需要注意的是，在 Python 中创建进程，一定要在 <code>if __name__ == &#39;__main__&#39;:</code> 下创建，否则会报错。回到正题，可以看到，在输出结果中，单线程耗时 162.31ms，而多线程耗时 1328.57ms，基本上等于 8 倍的单线程时间，也就是说实际上在 Python 中多进程完全无法利用多核 CPU 进行加速，这是由于 GIL 的存在。那么多进程小号的时间则为 886.85 ms，明显是有一个加速在的。可是按道理来说，我电脑是 8 核的，应该是和单线程的耗时差不多，也为 162ms左右，为什么还是多出这么多呢？总结一句话：Python 多进程<strong>理论上能绕开 GIL 实现并行计算</strong>，但实际效果远达不到 1&#x2F;N 原因在于：<strong>进程创建&#x2F;序列化&#x2F;调度开销、系统资源调度不稳定、任务不够重、尾程影响大</strong>。如果你愿意尝试的话，可以将 10_000_00 改为 100_000_00，你会发现优化的时间会越来越接近于 1&#x2F;N。</p>
<p>​	另外多进程的话是不需要考虑锁的问题的，因为多进程之间无法共享内存，或者说无法简单的共享内存，我们在编程的时候基本上不需要考虑。</p>
<h2 id="10-ContextManager"><a href="#10-ContextManager" class="headerlink" title="10. ContextManager"></a>10. ContextManager</h2><p>​	<code>with</code> 后面跟上一个 <code>Timer()</code> 的类之后，会直接执行类中的 <code>__enter__()</code> 方法，然后将 <code>__enter__()</code> 方法的返回值返回给 <code>as</code> 后面的变量，在代码中是 <code>timer</code>，随后当 <code>with</code> 中的语句执行完成之后，会调用 <code>Timer()</code> 中的 <code>__exit__()</code> 方法。那么最后再调用一下 <code>timer.elapsed</code> 就可以实现程序计时了。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.elapsed = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.start = time.perf_counter()</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="variable language_">self</span>.end = time.perf_counter()</span><br><span class="line">        <span class="variable language_">self</span>.elapsed = <span class="variable language_">self</span>.end - <span class="variable language_">self</span>.start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Timer() <span class="keyword">as</span> timer:</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">        nums.append(n ** <span class="number">2</span>)</span><br><span class="line">    end = time.perf_counter()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;timer.elapsed * <span class="number">1000</span>&#125;</span>ms&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	简单总结一下，ContextManager其实很简单，就是关键字 <code>with</code> 后面跟着的类会在开始的时候执行 <code>__enter__()</code> 函数，并将该函数的返回值赋给 <code>as</code> 后面的变量，然后在结束的时候执行 <code>__end__()</code> 函数。</p>
<p>​	<strong>ContextManager 的应用有：</strong></p>
<ul>
<li>开 - 关</li>
<li>锁 - 释放</li>
<li>启动 -停止</li>
<li>改变 - 重置</li>
</ul>
<h2 id="11-asyncio"><a href="#11-asyncio" class="headerlink" title="11. asyncio"></a>11. asyncio</h2><h3 id="1-coroutine"><a href="#1-coroutine" class="headerlink" title="1. coroutine"></a>1. coroutine</h3><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h4 id="1-property"><a href="#1-property" class="headerlink" title="1. @property"></a>1. @property</h4><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1iD4y1476Q/?spm_id_from=333.337.search-card.all.click&vd_source=a3a7b6035d802044a698f0b0e846a493">面向对象的Python编程-07.property类_哔哩哔哩_bilibili</a></p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Way2top</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://example.com/2025/07/01/Advanced%20Python/">http://example.com/2025/07/01/Advanced%20Python/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Way2top</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2025/08/16/hello-world/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="Hello World">
                        
                        <span class="card-title">Hello World</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2025-08-16
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Way2top
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                本篇&nbsp;<i class="far fa-dot-circle"></i>
            </div>
            <div class="card">
                <a href="/2025/07/01/Advanced%20Python/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/22.jpg" class="responsive-img" alt="Advanced Python">
                        
                        <span class="card-title">Advanced Python</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2025-07-01
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Way2top
                            
                        </span>
                    </div>
                </div>

                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>



<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2025</span>
            
            <a href="/about" target="_blank">Way2top</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1181062873@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1181062873" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1181062873" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
